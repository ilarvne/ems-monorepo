// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: events.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const addEventTag = `-- name: AddEventTag :exec
INSERT INTO event_tags (event_id, tag_id) VALUES ($1, $2)
`

type AddEventTagParams struct {
	EventID int32 `json:"event_id"`
	TagID   int32 `json:"tag_id"`
}

func (q *Queries) AddEventTag(ctx context.Context, arg AddEventTagParams) error {
	_, err := q.db.Exec(ctx, addEventTag, arg.EventID, arg.TagID)
	return err
}

const countEvents = `-- name: CountEvents :one
SELECT COUNT(DISTINCT e.id)
FROM events e
LEFT JOIN event_tags et ON et.event_id = e.id
WHERE 
    ($1::int IS NULL OR e.user_id = $1) AND
    ($2::int IS NULL OR e.organization_id = $2) AND
    ($3::int[] IS NULL OR et.tag_id = ANY($3::int[]))
`

type CountEventsParams struct {
	UserID         pgtype.Int4 `json:"user_id"`
	OrganizationID pgtype.Int4 `json:"organization_id"`
	TagIds         []int32     `json:"tag_ids"`
}

func (q *Queries) CountEvents(ctx context.Context, arg CountEventsParams) (int64, error) {
	row := q.db.QueryRow(ctx, countEvents, arg.UserID, arg.OrganizationID, arg.TagIds)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countTags = `-- name: CountTags :one
SELECT COUNT(*) FROM tags
`

func (q *Queries) CountTags(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countTags)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createEvent = `-- name: CreateEvent :one
INSERT INTO events (title, description, image_url, user_id, organization_id, location, start_time, end_time, format)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, COALESCE($9::format, 'offline'::format))
RETURNING id, title, description, image_url, user_id, organization_id, location, start_time, end_time, format, created_at, updated_at
`

type CreateEventParams struct {
	Title          string             `json:"title"`
	Description    string             `json:"description"`
	ImageUrl       pgtype.Text        `json:"image_url"`
	UserID         int32              `json:"user_id"`
	OrganizationID int32              `json:"organization_id"`
	Location       string             `json:"location"`
	StartTime      pgtype.Timestamptz `json:"start_time"`
	EndTime        pgtype.Timestamptz `json:"end_time"`
	Format         NullFormat         `json:"format"`
}

func (q *Queries) CreateEvent(ctx context.Context, arg CreateEventParams) (Event, error) {
	row := q.db.QueryRow(ctx, createEvent,
		arg.Title,
		arg.Description,
		arg.ImageUrl,
		arg.UserID,
		arg.OrganizationID,
		arg.Location,
		arg.StartTime,
		arg.EndTime,
		arg.Format,
	)
	var i Event
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Description,
		&i.ImageUrl,
		&i.UserID,
		&i.OrganizationID,
		&i.Location,
		&i.StartTime,
		&i.EndTime,
		&i.Format,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createTag = `-- name: CreateTag :one
INSERT INTO tags (name)
VALUES ($1)
RETURNING id, name, created_at, updated_at
`

func (q *Queries) CreateTag(ctx context.Context, name string) (Tag, error) {
	row := q.db.QueryRow(ctx, createTag, name)
	var i Tag
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteEvent = `-- name: DeleteEvent :exec
DELETE FROM events WHERE id = $1
`

func (q *Queries) DeleteEvent(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, deleteEvent, id)
	return err
}

const deleteTag = `-- name: DeleteTag :exec
DELETE FROM tags WHERE id = $1
`

func (q *Queries) DeleteTag(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, deleteTag, id)
	return err
}

const getEvent = `-- name: GetEvent :one
SELECT id, title, description, image_url, user_id, organization_id, location, start_time, end_time, format, created_at, updated_at FROM events WHERE id = $1
`

func (q *Queries) GetEvent(ctx context.Context, id int32) (Event, error) {
	row := q.db.QueryRow(ctx, getEvent, id)
	var i Event
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Description,
		&i.ImageUrl,
		&i.UserID,
		&i.OrganizationID,
		&i.Location,
		&i.StartTime,
		&i.EndTime,
		&i.Format,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getEventTagIDs = `-- name: GetEventTagIDs :many
SELECT tag_id FROM event_tags WHERE event_id = $1
`

func (q *Queries) GetEventTagIDs(ctx context.Context, eventID int32) ([]int32, error) {
	rows, err := q.db.Query(ctx, getEventTagIDs, eventID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int32
	for rows.Next() {
		var tag_id int32
		if err := rows.Scan(&tag_id); err != nil {
			return nil, err
		}
		items = append(items, tag_id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEventTags = `-- name: GetEventTags :many
SELECT t.id, t.name, t.created_at, t.updated_at
FROM tags t
INNER JOIN event_tags et ON et.tag_id = t.id
WHERE et.event_id = $1
`

func (q *Queries) GetEventTags(ctx context.Context, eventID int32) ([]Tag, error) {
	rows, err := q.db.Query(ctx, getEventTags, eventID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Tag
	for rows.Next() {
		var i Tag
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEventsByTagID = `-- name: GetEventsByTagID :many
SELECT e.id, e.title, e.description, e.image_url, e.user_id, e.organization_id, e.location, e.start_time, e.end_time, e.format, e.created_at, e.updated_at
FROM events e
INNER JOIN event_tags et ON et.event_id = e.id
WHERE et.tag_id = $1
`

func (q *Queries) GetEventsByTagID(ctx context.Context, tagID int32) ([]Event, error) {
	rows, err := q.db.Query(ctx, getEventsByTagID, tagID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Event
	for rows.Next() {
		var i Event
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Description,
			&i.ImageUrl,
			&i.UserID,
			&i.OrganizationID,
			&i.Location,
			&i.StartTime,
			&i.EndTime,
			&i.Format,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTag = `-- name: GetTag :one
SELECT id, name, created_at, updated_at FROM tags WHERE id = $1
`

func (q *Queries) GetTag(ctx context.Context, id int32) (Tag, error) {
	row := q.db.QueryRow(ctx, getTag, id)
	var i Tag
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listEvents = `-- name: ListEvents :many
SELECT DISTINCT e.id, e.title, e.description, e.image_url, e.user_id, e.organization_id, e.location, e.start_time, e.end_time, e.format, e.created_at, e.updated_at
FROM events e
LEFT JOIN event_tags et ON et.event_id = e.id
WHERE 
    ($3::int IS NULL OR e.user_id = $3) AND
    ($4::int IS NULL OR e.organization_id = $4) AND
    ($5::int[] IS NULL OR et.tag_id = ANY($5::int[]))
ORDER BY e.id
LIMIT $1 OFFSET $2
`

type ListEventsParams struct {
	Limit          int32       `json:"limit"`
	Offset         int32       `json:"offset"`
	UserID         pgtype.Int4 `json:"user_id"`
	OrganizationID pgtype.Int4 `json:"organization_id"`
	TagIds         []int32     `json:"tag_ids"`
}

func (q *Queries) ListEvents(ctx context.Context, arg ListEventsParams) ([]Event, error) {
	rows, err := q.db.Query(ctx, listEvents,
		arg.Limit,
		arg.Offset,
		arg.UserID,
		arg.OrganizationID,
		arg.TagIds,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Event
	for rows.Next() {
		var i Event
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Description,
			&i.ImageUrl,
			&i.UserID,
			&i.OrganizationID,
			&i.Location,
			&i.StartTime,
			&i.EndTime,
			&i.Format,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTags = `-- name: ListTags :many
SELECT id, name, created_at, updated_at FROM tags
ORDER BY id
LIMIT $1 OFFSET $2
`

type ListTagsParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) ListTags(ctx context.Context, arg ListTagsParams) ([]Tag, error) {
	rows, err := q.db.Query(ctx, listTags, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Tag
	for rows.Next() {
		var i Tag
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const removeEventTags = `-- name: RemoveEventTags :exec
DELETE FROM event_tags WHERE event_id = $1
`

func (q *Queries) RemoveEventTags(ctx context.Context, eventID int32) error {
	_, err := q.db.Exec(ctx, removeEventTags, eventID)
	return err
}

const updateEvent = `-- name: UpdateEvent :one
UPDATE events
SET title = COALESCE($1, title),
    description = COALESCE($2, description),
    image_url = COALESCE($3, image_url),
    user_id = COALESCE($4, user_id),
    organization_id = COALESCE($5, organization_id),
    location = COALESCE($6, location),
    start_time = COALESCE($7, start_time),
    end_time = COALESCE($8, end_time),
    format = COALESCE($9::format, format),
    updated_at = NOW()
WHERE id = $10
RETURNING id, title, description, image_url, user_id, organization_id, location, start_time, end_time, format, created_at, updated_at
`

type UpdateEventParams struct {
	Title          pgtype.Text        `json:"title"`
	Description    pgtype.Text        `json:"description"`
	ImageUrl       pgtype.Text        `json:"image_url"`
	UserID         pgtype.Int4        `json:"user_id"`
	OrganizationID pgtype.Int4        `json:"organization_id"`
	Location       pgtype.Text        `json:"location"`
	StartTime      pgtype.Timestamptz `json:"start_time"`
	EndTime        pgtype.Timestamptz `json:"end_time"`
	Format         NullFormat         `json:"format"`
	ID             int32              `json:"id"`
}

func (q *Queries) UpdateEvent(ctx context.Context, arg UpdateEventParams) (Event, error) {
	row := q.db.QueryRow(ctx, updateEvent,
		arg.Title,
		arg.Description,
		arg.ImageUrl,
		arg.UserID,
		arg.OrganizationID,
		arg.Location,
		arg.StartTime,
		arg.EndTime,
		arg.Format,
		arg.ID,
	)
	var i Event
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Description,
		&i.ImageUrl,
		&i.UserID,
		&i.OrganizationID,
		&i.Location,
		&i.StartTime,
		&i.EndTime,
		&i.Format,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateTag = `-- name: UpdateTag :one
UPDATE tags
SET name = COALESCE($1, name),
    updated_at = NOW()
WHERE id = $2
RETURNING id, name, created_at, updated_at
`

type UpdateTagParams struct {
	Name pgtype.Text `json:"name"`
	ID   int32       `json:"id"`
}

func (q *Queries) UpdateTag(ctx context.Context, arg UpdateTagParams) (Tag, error) {
	row := q.db.QueryRow(ctx, updateTag, arg.Name, arg.ID)
	var i Tag
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
